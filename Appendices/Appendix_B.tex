\chapter{Appendix: Handover}

%%\subsection{Algorithm: position prediction model}

\begin{algorithm}[H] \label{positionalgo}
	\DontPrintSemicolon
	\SetNoFillComment
	
	\KwInput{$\mathcal{}^{M}{X}_R, {}^{ef}{X}_R, mocapData$}
	\KwOutput{${}^{h}wp_{ef}$ \tcp*{predicted waypoints}  }
	\KwData{Initial require: $t_{observe}=20ms, t_{predict}=200ms, i=dt=5ms$}
	
	
	\textit{$\textbf{i+=dt}$} \tcp*{increments as per controller run-time (dt)}
	
	\If{$(i\%t_{observe})==0$}
	{
		\For{$j = 1 \textrm{ to } t_{observe} $}
		{
			${}^{h}\mathcal{P}_M= \textit{mocapData}.handMarker(i-t_{observe})+j)$	
		}
		
		${}^{h}\mathcal{\bar{V}}_{M} = \frac{1}{t_{observe}}{\sum_{j=1}^{j=t_{observe}} ({}^{h}\mathcal{P}_{M}(j)-{}^{h}\mathcal{P}_{M}(j-1))/dt }$\newline 
		
		\tcc{predict human hand handover position at $t_{predict}$}
		${}^{h}\mathcal{P}_M(t_{predict}) = {}^{h}\mathcal{\bar{V}}_{M} \cdot t_{predict}  + {}^{h}\mathcal{P}_{M}(t_{observe})$ %\newline % \times 0.005
		
		
		${}^{h}{X}_M= \begin{bmatrix} {}^{h}\mathcal{O}_{M} &  {}^{h}\mathcal{P}_M	\end{bmatrix}$ \newline
		
		\tcc{transform handover position relative to robot end-effector}	
		${}^{h}{X}_{ef}(t_{predict}) =  {}^{h}{X}_M  {}^{M}{X}_R {{}^{ef}{X}_R}^{-1}$ \newline
		
		
		\tcc{\textit{way points between human hand and robot end-effector handover location}}
		\SetKwFunction{FMain}{generateWp}
		\SetKwProg{Fn}{Function}{:}{}
		\Fn{\FMain{$ {}^{ef}\mathcal{P}_{R}, {}^{h}\mathcal{P}_{ef}(t_{predict}), t_{predict} $}}
		{
			\For{$k = 0 \textrm{ to } t_{predict} $}
			{
				${}^{h}wp_{ef}(k) = [{}^{h}\mathcal{P}_{ef}(t_{predict}) - {}^{ef}\mathcal{P}_{R}] . (\frac{k}{t_{predict}})  + {}^{ef}\mathcal{P}_{R} $ 
			}	
			\textbf{return} $ {}^{h}wp_{ef} $
		}
	}
	\caption{linear position prediction model}
\end{algorithm}

\clearpage


%%\subsection{Algorithm: interaction forces}


\begin{algorithm}[H]\label{interaction forces}
	\DontPrintSemicolon
	\SetNoFillComment
	
	\KwInput{$\mathcal{F}$\tcp*{EF wrist worldWrenchWithoutGravity}}
	\KwOutput{${}^{pull}\mathcal{F}, {}^{new}T$ \tcp*{Pull force, new threshold based on object mass\newline} }
	% 	\textit{$\textbf{dt++}$} \tcp*{increments as per controller run-time (5ms)}
	
	\If{\text{human hand is near robot}}
	{
		\tcc{when human holds the object}
		\If{$\norm{{}^h{P} - {}^{ef}{P}} < 0.05$ \tcp*{gripper is empty}}
		{
			Open Gripper\\
			$\mathcal{}^{zero}{F}= \mathcal{F}$ \tcp*{wrench offset}
		}
		\tcc{when robot holds the object}
		${}^{obj}\overline{\mathcal{F}} = \frac{1}{n}\sum_{i=1}^{i=n} \vert{ (\vert{\mathcal{F}} - \vert{{}^{zero}\mathcal{F}}) }$
		
		$objectMass = \norm{{}^{obj}\overline{\mathcal{F}}}/9.80665 $ \tcp*{get object mass}
		
		${}^{inert}\mathcal{F} = objectMass * efAce$ \tcp*{$efAce$ - avg end-effector acceleration}
		
		${}^{new}T = {}^{obj}\overline{\mathcal{F}} + {}^{old}T$ \tcp*{$T_{old}$ set to [5,5,5]}
		
		\SetKwFunction{FMain}{CheckPullForce}
		\SetKwProg{Fn}{Function}{:}{}
		\Fn{\FMain{$\lor x, \lor y, \lor z$}}
		{	
			${}^{pull}\mathcal{F} = \vert{(\vert\mathcal{{F}} - \vert{}^{inert}\mathcal{{F}} - \vert{}^{zero}\mathcal{{F}}) }$
			
			\If{${}^{pull}\mathcal{F} > {}^{new}T \lor x, \lor y, \lor z$}
			{
				\textrm{release object}\tcp*{release object}
			}
		}
	}
	\caption{Interaction Forces}
\end{algorithm}































\clearpage % end of appendix


%\begin{lstlisting}[language=C++,basicstyle=\footnotesize, caption={wrench}]
%const sva::ForceVecd 
%ForceSensor::wrenchWithoutGravity(const mc_rbdyn::Robot & robot) const
%{
%sva::PTransformd X_0_p = 
%robot.mbc().bodyPosW[robot.bodyIndexByName(parentBody_)];
%auto w = wrench_ - calibration_->wfToSensor(X_0_p, X_p_f_);
%return w;
%}
%
%sva::ForceVecd 
%ForceSensor::worldWrench(const mc_rbdyn::Robot & robot) const
%{
%sva::ForceVecd w_fsactual = wrench();
%sva::PTransformd X_parent_0 = 
%robot.mbc().bodyPosW[robot.bodyIndexByName(parentBody_)].inv();
%sva::PTransformd X_fsactual_0 = X_parent_0 * X_fsactual_parent();
%return X_fsactual_0.dualMul(w_fsactual);
%}
%
%sva::ForceVecd 
%ForceSensor::worldWrenchWithoutGravity(const mc_rbdyn::Robot & robot) const
%{
%sva::ForceVecd w_fsactual = wrenchWithoutGravity(robot);
%sva::PTransformd X_parent_0 = 
%robot.mbc().bodyPosW[robot.bodyIndexByName(parentBody_)].inv();
%sva::PTransformd X_fsactual_0 = X_parent_0 * X_fsactual_parent();
%return X_fsactual_0.dualMul(w_fsactual);
%}
%\end{lstlisting}
%
%
%
%
%\begin{lstlisting}[language=C++,basicstyle=\footnotesize, caption={QPContactConstr}]
%
%void ContactSpeedConstr::update(const std::vector<rbd::MultiBody>& mbs,
%const std::vector<rbd::MultiBodyConfig>& mbcs,
%const SolverData& data)
%{
%using namespace Eigen;
%
%A_.block(0, 0, nrEq_, totalAlphaD_).setZero();
%b_.head(nrEq_).setZero();
%// J_i*alphaD + JD_i*alpha = 0
%
%int index = 0;
%for(std::size_t i = 0; i < cont_.size(); ++i)
%{
%ContactData& cd = cont_[i];
%int rows = int(cd.dof.rows());
%
%for(std::size_t j = 0; j < cd.contacts.size(); ++j)
%{
%ContactSideData& csd = cd.contacts[j];
%const rbd::MultiBody& mb = mbs[csd.robotIndex];
%const rbd::MultiBodyConfig& mbc = mbcs[csd.robotIndex];
%
%// AEq = J_i
%sva::PTransformd X_0_p = csd.X_b_p*mbc.bodyPosW[csd.bodyIndex];
%const MatrixXd& jacMat = csd.jac.jacobian(mb, mbc, X_0_p);
%dofJac_.block(0, 0, rows, csd.jac.dof()).noalias() =
%csd.sign*cd.dof*jacMat;
%csd.jac.fullJacobian(mb, dofJac_.block(0, 0, rows, csd.jac.dof()),
%fullJac_);
%A_.block(index, csd.alphaDBegin, rows, mb.nrDof()).noalias() +=
%fullJac_.block(0, 0, rows, mb.nrDof());
%
%// BEq = -JD_i*alpha
%Vector6d normalAcc = csd.jac.normalAcceleration(
%mb, mbc, data.normalAccB(csd.robotIndex), csd.X_b_p,
%sva::MotionVecd(Vector6d::Zero())).vector();
%Vector6d velocity = csd.jac.velocity(mb, mbc, csd.X_b_p).vector();
%b_.segment(index, rows).noalias() -= csd.sign*cd.dof*(normalAcc +
%velocity/timeStep_);
%}
%index += rows;
%}
%}
%\end{lstlisting}
