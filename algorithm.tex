\documentclass{article}

\usepackage{amsmath}
\usepackage{physics}

\usepackage{xcolor}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

%opening
\title{Thesis overview}
\author{Ashesh Vasalya}

%%% Coloring the comment as blue
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}

\SetKwInput{KwInput}{Input}                % Set the Input
\SetKwInput{KwOutput}{Output}


%\usepackage{algpseudocode,algorithm} % algorithmicx
%\usepackage{algorithm}
%\usepackage[ruled,vlined,linesnumbered]{algorithm}


\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother





\begin{document}

\maketitle

---- paper -- Predicting Object Transfer Position and Timing in Human-robot Handover Tasks
\paragraph{}

----an idea --have velocity proportional to the distance between robot ef and subj w.r.t. handover location\newpage

\begin{algorithm}[H]
\DontPrintSemicolon

		\KwInput{$\mathcal{}^{ef}{T}_R, mocapData$}
		\KwOutput{${}^{obj}wp_{ef}$ \tcp*{predicted waypoints}  }
		\KwData{Initial require: $t_{observe}=150ms, t_{predict}=3sec, i=1$}
		
		
        \textit{$\textbf{i++}$} \tcp*{increments as per controller run-time (5ms)}
		 
		\If{$(i\%t_{observe})==0$ }%\newline
		{
		 	$\mathcal{}^{ef_{marker}}{T}_M\gets \textit{mocapData}.robotMarker((i-t_{observe})+1)$
		

			\For{$j \gets 1 \textrm{ to } t_{observe} $}
			{
			 	$\mathcal{}^{obj_{marker}}{T}_M\gets \textit{mocapData}.objectMarker(i-t_{observe})+j)$	
				
				$\mathcal{}^{obj_{marker}}{T}_{ef}(j) = \mathcal{}^{ef}{T}_R^{-1} \times  \mathcal{}^{obj_{marker}}{T}_M \times {\mathcal{}^{ef_{marker}}{T}_M}^{-1} \times  \mathcal{}^{ef}{T}_R$	
				
				\If{$j== t_{observe}$}
				{
					${}^{obj_{marker}}P_{ef}(t_{observe}) \gets \mathcal{}^{obj_{marker}}{T}_{ef}.translation()(t_{observe}) $
				}
			}
		
			${}^{h}\mathcal{\bar{V}}_{ef} \gets \mathcal{F}_{avg}(\mathcal{}^{h}{T}_{ef}.translation())$	\newline 
			\tcc{or}
			${}^{h}\mathcal{\bar{V}}_{ef} = \frac{1}{t_{observe}}{\sum_{j=1}^{j=t_{observe}} (\mathcal{}^{h}{T}_{ef}.translation())}$	\newline 
		
		
		
			\tcc{predict position of object handover at $t_{predict}$}
			${}^{h}P_{t_{predict}} \gets {}^{h}\mathcal{\bar{V}}_{ef} \cdot t_{predict}  + {}^{h}P_{ef}(t_{observe})$ \newline % \times 0.005
			
			\tcc{\textit{generate way points between robot left end effector and object handover location}}
			\SetKwFunction{FMain}{generateWp}
			\SetKwProg{Fn}{Function}{:}{}
			\Fn{\FMain{${}^{obj_{marker}}P_{ef}(t_{observe}), {}^{obj}P_{t_{predict}}, t_{predict} $}}
			{
				\For{$k \gets 0 \textrm{ to } t_{predict} $}
				{
					${}^{obj}wp_{ef}(k) \gets ( {}^{obj_{marker}}P_{ef}(t_{observe}) - {}^{obj}P_{t_{predict}}  ) \times k  -  {}^{obj_{marker}}P_{ef}(t_{observe}) $ 
				}	
				\textbf{return} $ {}^{obj}wp_{ef} $
			}
		}
\caption{linear prediction controller}
\end{algorithm}

\newpage

\begin{algorithm}[H] \label{positionalgo}
	\DontPrintSemicolon
	
	\KwInput{$\mathcal{}^{ef}{X}_R, mocapData$}
	\KwOutput{${}^{obj}wp_{ef}$ \tcp*{predicted waypoints}  }
	\KwData{Initial require: $t_{observe}=150ms, t_{predict}=3sec, i=1, dt=5ms$}
	
	
	\textit{$\textbf{i++}$} \tcp*{increments as per controller run-time (5ms)}
	
	\If{$(i\%t_{observe})==0$ }%\newline
	{		
		\For{$j = 1 \textrm{ to } t_{observe} $}
		{
			${}^{h}{X}_M= \textit{mocapData}.handMarker(i-t_{observe})+j)$	
			
			${}^{h}{X}_{ef}(j) =  {}^{h}{X}_M  {}^{M}{X}_R {{}^{ef}{X}_R}^{-1}$	
			
			\If{$j== t_{observe}$}
			{
				${}^{h}\mathcal{P}_{ef}(t_{observe}) = \mathcal{}^{h}{X}_{ef}.translation()(t_{observe}) $
			}
		}
		
		${}^{h}\mathcal{\bar{V}}_{ef} = \frac{1}{t_{observe}}{\sum_{j=1}^{j=t_{observe}} f'({}^{h}\mathcal{P}_{ef})/dt }$\newline 
		
		
		\tcc{predict subject's hand handover position at $t_{predict}$}
		${}^{h}\mathcal{P}_{t_{predict}} = {}^{h}\mathcal{\bar{V}}_{ef} \cdot t_{predict}  + {}^{h}P_{ef}(t_{observe})$ \newline % \times 0.005
		
		\tcc{\textit{generate way points between subject hand and robot left end-effector handover location}}
		\SetKwFunction{FMain}{generateWp}
		\SetKwProg{Fn}{Function}{:}{}
		\Fn{\FMain{${}^{h}\mathcal{P}_{ef}(t_{observe}), {}^{h}\mathcal{P}_{t_{predict}}, t_{predict} $}}
		{
			\For{$k = 0 \textrm{ to } t_{predict} $}
			{
				${}^{h}wp_{ef}(k) = ( {}^{h}\mathcal{P}_{ef}(t_{observe}) - {}^{h}\mathcal{P}_{t_{predict}}  ) \times k  -  {}^{h}\mathcal{P}_{ef}(t_{observe}) $ 
			}	
			\textbf{return} $ {}^{h}wp_{ef} $
		}
	}
	\caption{linear prediction controller - Position}
\end{algorithm}

\newpage


\section*{}
Our prediction controller behavior can be tuned by two initially required constant time periods, $t_{observe}$ ---which defines the time period required to observe the motion of object and $t_{predict}$ ---required to predict the object handover location in advance.

\paragraph*{}
Inputs of the controller are robot left end effector pose $\mathcal{}^{ef}{T}_R$ and mocap markers position data in the mocap frame of reference $mocapFrameData$. $\mathcal{}^{ef_{marker}}{T}_M$ is the left end effector marker pose in the mocap frame. Similarly, object marker pose given by $\mathcal{}^{obj_{marker}}{T}_M$. For simplicity, at the moment, we have assumed zero rotation of the markers and end effector, therefore rotation part of $\mathcal{}^{ef}{T}_R$, $\mathcal{}^{efl_{marker}}{T}_M$ and $\mathcal{}^{obj_{marker}}{T}_M$ are Identity matrix $\mathcal{I}$. 

\paragraph*{}
The transformation matrix $\mathcal{}^{obj_{marker}}{T}_{ef}$, provides the relative pose of object marker w.r.t. robot left end effector in the robot coordinate system. $P^{obj_{marker}}_0$ $P^{obj_{marker}}_{t_{observe}}$ are the updated observed positions of object whenever the condition ($i\%t_{observe}==0$) satisfy. Based on the  $P^{obj_{marker}}_0$ $P^{obj_{marker}}_{t_{observe}}$, average velocity $\mathcal{\bar{V}}^{ef}_{obj_{marker}}$ of the observed object motion calculated. Where, $\mathcal{F}_c$, $\mathcal{F}_{diff}$, $\mathcal{F}_{avg}$ are the \textit{helper functions}.

\paragraph*{}
Function $PREDICTPOS$, returns the predicted position of the handover $P^{obj}_{t_{predict}}$ at time $t_{predict}$.

Function $GENERATEWP$, returns the way-points $wp^{ef}_{obj}$ between robot left end effector and object handover location, which is the final output of the controller. 

Later, $wp^{ef}_{obj}$ is being fed in the \texttt{mc\_rtc positionTask}.


\section*{}
\begin{algorithm}[H]
	\DontPrintSemicolon
	
	\KwInput{$\mathcal{F}_{w}$\tcp*{EF wrist worldWrenchWithoutGravity}}
	\KwOutput{$\mathcal{F}_{pull}, T_{new}$ \tcp*{Pull force, new threshold based on object mass\newline} }
    \textit{$\textbf{i++}$} \tcp*{increments as per controller run-time (5ms)}
	
	\If{subject hand is near robot}
	{
		\tcc{when SUBJECT holds the object}
		\If{$\mathcal{F}_{w}.norm()<1.0 $\tcp*{gripper is empty}}
		{
			$\mathcal{F}_{zero}\gets \mathcal{F}_{w}$\tcp*{wrench offset}
		}
		\ElseIf{$\mathcal{F}_{w}.norm()>2.0 $}
		{
			$\mathcal{F}_{load}\gets \mathcal{F}_{w}$\tcp*{wrench with object}
		}
		\tcc{when ROBOT holds the object}
			\SetKwFunction{FMain}{CheckPullForce}
		\SetKwProg{Fn}{Function}{:}{}
		\Fn{\FMain{$axis\forall${x,y,z}}}
		{
			$objectMass \gets \mathcal{F}_{load}/9.81 $\tcp*{get object mass}

			$\mathcal{F}_{inert} \gets objectMass * efAce  $\tcp*{$efAce$ using gripper markers}

			$\mathcal{F}_{pull} \gets \vert{(\mathcal\vert{{F}}_{w} - \mathcal\vert{{F}}_{inert})}$
			
			$T_{new} \gets \mathcal{F}_{load} + T_{old}$\tcp*{$T_{old}$ set to min by user}
			
			\If{$\mathcal{F}_{pull} > T_{new}$ {$\forall${x,y,z}}}
			{
				$openGripper$\tcp*{release object}
			}
			
		}
	
	}
	\Else
	{
		\If{$(i \% 200)$}
		{
			$\mathcal{F}_{load} \gets \vert{(\mathcal{F}_{w} - \mathcal{F}_{zero})} $\tcp*{$\forall${x,y,z} average over time}
		}
	}
	
	
	\caption{Force Based Gripper Controller}
\end{algorithm}




\end{document}
