\documentclass{article}

\usepackage{amsmath}
\usepackage{physics}

\usepackage{xcolor}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

%opening
\title{Thesis overview}
\author{Ashesh Vasalya}

%%% Coloring the comment as blue
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}

\SetKwInput{KwInput}{Input}                % Set the Input
\SetKwInput{KwOutput}{Output}


%\usepackage{algpseudocode,algorithm} % algorithmicx
%\usepackage{algorithm}
%\usepackage[ruled,vlined,linesnumbered]{algorithm}


\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother





\begin{document}

\maketitle

\begin{algorithm}[H]
\DontPrintSemicolon

		\KwInput{$\mathcal{T}^{efL}_R, mocapData$}
		\KwOutput{$wp^{obj}_{efL}$ \tcp*{predicted waypoints}  }
		\KwData{Initial require: $t_{observe}=150ms, t_{predict}=3sec, i=1$}
		
        \textit{$\textbf{i++}$} \tcp*{increments as per controller run-time (5ms)}
		 
		\If{$(i\%t_{observe})==0$ }%\newline
		{
			$\mathcal{T}^{efL}_R\gets \textit{endEffectorTask}$
		 $\mathcal{T}^{efL_{marker}}_M\gets \textit{mocapData}.robotMarker((i-t_{observe})+1)$
		}

		\For{$j \gets 1 \textrm{ to } t_{observe} $}
		{
		 $\mathcal{T}^{obj_{marker}}_M\gets \textit{mocapData}.objectMarker(i-t_{observe})+j)$	
			
			$\mathcal{T}^{obj_{marker}}_{efL} = {\mathcal{T}^{efL}_R}^{-1} \times  \mathcal{T}^{obj_{marker}}_M \times {\mathcal{T}^{efL_{marker}}_M}^{-1} \times  \mathcal{T}^{efL}_R$	
			
			\If{$j== t_{observe}$}
			{
				$P^{obj_{marker}}_{t_{observe}} \gets \mathcal{T}^{obj_{marker}}_{efL}.translation()(t_{observe}) $
			}
		}
		
		$\mathcal{\bar{V}}^{efL}_{obj_{marker}} \gets \mathcal{F}_{avg}(\mathcal{T}^{obj_{marker}}_{efL}.translation())$	\newline 
	

	
		\tcc{predict position of object handover at $t_{predict}$}
		  $P^{obj}_{t_{predict}} \gets \mathcal{\bar{V}}^{efL}_{obj_{marker}}\times t_{predict}  +{P^{obj_{marker}}_{t_{observe}}(t_{observe})}$ \newline % \times 0.005
		


	\tcc{\textit{generate way points between robot left end effector and object handover location}}
	\SetKwFunction{FMain}{generateWp}
	\SetKwProg{Fn}{Function}{:}{}
	\Fn{\FMain{$P^{obj_{marker}}_{t_{observe}}, P^{obj}_{t_{predict}}, t_{predict} $}}
	{
		\For{$k \gets 0 \textrm{ to } t_{predict} $}
		{
			$wp^{obj}_{efL}(k) \gets (P^{obj}_{t_{predict}} - P^{obj_{marker}}_{t_{observe}}) \times k  +  P^{obj_{marker}}_{t_{observe}} $ 
		}	
		\textbf{return} $ wp^{obj}_{efL} $
	}

\caption{linear prediction controller}
\end{algorithm}


\section*{}
Our prediction controller behavior can be tuned by two initially required constant time periods, $t_{observe}$ ---which defines the time period required to observe the motion of object and $t_{predict}$ ---required to predict the object handover location in advance.

\paragraph*{}
Inputs of the controller are robot left end effector pose $\mathcal{T}^{efL}_R$ and mocap markers position data in the mocap frame of reference $mocapFrameData$. $\mathcal{T}^{efL_{marker}}_M$ is the left end effector marker pose in the mocap frame. Similarly, object marker pose given by $\mathcal{T}^{obj_{marker}}_M$. For simplicity, at the moment, we have assumed zero rotation of the markers and end effector, therefore rotation part of $\mathcal{T}^{efL}_R$, $\mathcal{T}^{efl_{marker}}_M$ and $\mathcal{T}^{obj_{marker}}_M$ are Identity matrix $\mathcal{I}$. 

\paragraph*{}
The transformation matrix $\mathcal{T}^{efL}_{obj_{marker}}$, provides the relative pose of object marker w.r.t. robot left end effector in the robot coordinate system. $P^{obj_{marker}}_0$ $P^{obj_{marker}}_{t_{observe}}$ are the updated observed positions of object whenever the condition ($i\%t_{observe}==0$) satisfy. Based on the  $P^{obj_{marker}}_0$ $P^{obj_{marker}}_{t_{observe}}$, average velocity $\mathcal{\bar{V}}^{efL}_{obj_{marker}}$ of the observed object motion calculated. Where, $\mathcal{F}_c$, $\mathcal{F}_{diff}$, $\mathcal{F}_{avg}$ are the \textit{helper functions}.

\paragraph*{}
Function $PREDICTPOS$, returns the predicted position of the handover $P^{obj}_{t_{predict}}$ at time $t_{predict}$.

Function $GENERATEWP$, returns the way-points $wp^{efL}_{obj}$ between robot left end effector and object handover location, which is the final output of the controller. 

Later, $wp^{efL}_{obj}$ is being fed in the \texttt{mc\_rtc positionTask}.


\section*{}
\begin{algorithm}[H]
	\DontPrintSemicolon
	
	\KwInput{$\mathcal{F}_{w}$\tcp*{EF wrist worldWrenchWithoutGravity}}
	\KwOutput{$\mathcal{F}_{pull}, T_{new}$ \tcp*{Pull force, new threshold based on object mass\newline} }
    \textit{$\textbf{i++}$} \tcp*{increments as per controller run-time (5ms)}
	
	\If{subject hand is near robot}
	{
		\tcc{when SUBJECT holds the object}
		\If{$\mathcal{F}_{w}.norm()<1.0 $\tcp*{gripper is empty}}
		{
			$\mathcal{F}_{zero}\gets \mathcal{F}_{w}$\tcp*{wrench offset}
		}
		\ElseIf{$\mathcal{F}_{w}.norm()>2.0 $}
		{
			$\mathcal{F}_{object}\gets \mathcal{F}_{w}$\tcp*{wrench with object}
		}
		\tcc{when ROBOT holds the object}
			\SetKwFunction{FMain}{CheckPullForce}
		\SetKwProg{Fn}{Function}{:}{}
		\Fn{\FMain{$axis\forall${x,y,z}}}
		{
			$objectMass \gets \mathcal{F}_{load}/9.81 $\tcp*{get object mass}

			$\mathcal{F}_{inert} \gets objectMass * efAce  $\tcp*{$efAce$ using gripper markers}

			$\mathcal{F}_{pull} \gets \vert{(\mathcal\vert{{F}}_{w} - \mathcal\vert{{F}}_{inert})}$
			
			$T_{new} \gets \mathcal{F}_{load} + T_{old}$\tcp*{$T_{old}$ set to min by user}
			
			\If{$\mathcal{F}_{pull} > T_{new}$ {$\forall${x,y,z}}}
			{
				$openGripper$\tcp*{release object}
			}
			
		}
	
	}
	\Else
	{
		\If{$(i \% 200)$}
		{
			$\mathcal{F}_{load} \gets \vert{(\mathcal{F}_{w} - \mathcal{F}_{zero})} $\tcp*{$\forall${x,y,z} average over time}
		}
	}
	
	
	\caption{Force Based Gripper Controller}
\end{algorithm}




\end{document}
